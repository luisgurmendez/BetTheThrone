/*
 Copyright (c) 2015 Gustavo Gretter, http://www.mobileui.org

 Permission is hereby granted, free of charge, to any person
 obtaining a copy of this software and associated documentation
 files (the "Software"), to deal in the Software without
 restriction, including without limitation the rights to use,
 copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the
 Software is furnished to do so, subject to the following
 conditions:

 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 OTHER DEALINGS IN THE SOFTWARE.
 -----------------------------------------------------------------
 */
/******************************************************************************
 * Object MobileUI
 ******************************************************************************/
var mui = new (function() {
    this.version = {
        major : 0,
        minor : 4,
        maintenance : 7,
        toString : function() {
            return this.major + "." + this.minor + "." + this.maintenance;
        }
    };
    //Reference to himself
    //Referencia a sí mismo
    var me = this;

    this.DEF_ANDROID_EFFECT='NONE';
    this.DEF_IOS_EFFECT='OVERFLY_IN';
    this.DEF_WIN_EFFECT='OVERFLY_IN';
    this.DEF_WEBAPP_EFFECT='OVERFLY_IN';

    //Registered Viewports
    //Viewports registrados
    var viewports = new Array();

    /**
     * Creates and registers a Viewport. Return the Viewport object.
     * Crea y registra un Viewport. Retorna un objeto Viewport.
     */
    this.createViewport = function(viewportId, currentPageId) {
        for (var x=0; x<viewports.length; x++) {
            vp = viewports[x];
            if (vp.viewportId==viewportId) return vp;
        }
        var viewportObj = new Viewport(viewportId, currentPageId);
        viewports.push(viewportObj);
        return viewportObj;
    };

    /**
     * Registers a Viewport object created externally
     * Registrar un objeto Viewport creado externamente.
     */
    this.registerViewport = function(viewportObj) {
        for (var x=0; x<viewports.length; x++) {
            vp = viewports[x];
            if (vp.viewportId==viewportObj.viewportId) return vp;
        }
        viewports.push(viewportObj);
        return viewportObj;
    };

    /**
     * Remove a registerd
     * Elimina un viewport registrado.
     */
    this.removeViewport = function(viewportId) {
        var vp;
        for (var x=0; x<viewports.length; x++) {
            vp = viewports[x];
            //vp.removeScroll();
            if (vp.viewportId==viewportId) viewports.splice(x,1);
        }
    };

    /**
     * Returns an specific registered Viewport.
     * Retorna un Viewport registrado específico.
     */
    this.getViewport = function(viewportId) {
        var ret = null;
        var vp;
        for (var x=0; x<viewports.length; x++) {
            vp = viewports[x];
            if (vp.viewportId==viewportId) ret = vp;
        }
        return ret;
    };

    /**
     * Return an Array of Viewport objects with all Viewports registered.
     * Retrona un Array de objetos Viewport con todos los Viewports registrados.
     */
    this.getAllViewports = function() {
        return viewports;
    };

    /**
     * Return if is a mobile device and its platform
     * Example: mui.isMobileDevice.any() for query if its a any device mobile or mui.isMobileDevice.iOS() for query if its a iPhone or iPad device.
     *
     */
    this.isMobileDevice = {
        Android: function() {
            return navigator.userAgent.match(/Android/i)&&!me.isMobileDevice.Windows() ? true : false;
        },
        BlackBerry: function() {
            return navigator.userAgent.match(/BlackBerry/i)&&!me.isMobileDevice.Windows() ? true : false;
        },
        iOS: function() {
            return navigator.userAgent.match(/iPhone|iPad|iPod/i)&&!me.isMobileDevice.Windows() ? true : false;
        },
        Windows: function() {
            return navigator.userAgent.match(/IEMobile/i) ? true : false;
        },
        any: function() {
            return (me.isMobileDevice.Android() || me.isMobileDevice.BlackBerry() || me.isMobileDevice.iOS() || me.isMobileDevice.Windows());
        }
    };

    /**
     * Return true if window orientation is portrait.
     */
    this.isPortrait = function() {
        var o = me.getWindowOrientation();
        return o==0 || o==180;
    };

    /**
     * Return true if window orientation is landscape.
     */
    this.isLandscape = function() {
        var o = me.getWindowOrientation();
        return o==90|| o==-90;
    };

    /**
     * Return true if device is a tablet.
     *
     * Retorna true si el dispositivo es una tablet.
     */
    this.isTablet = function() {
        return (navigator.userAgent.match(/iPad/i) ? true : false || (me.isMobileDevice.Android() && screen.width<1000));
    };

    /**
     * Return true is device is a phone.
     *
     * Retorna true si el dispositivo es un teléfono.
     */
    this.isPhone = function() {
        return !me.isTablet();
    };

    /**
     * Return de window orientation.
     * Return 90 and -90 => landscape, 0 and 180 => portrait
     */
    this.getWindowOrientation = function() {
        if ("orientation" in window && !me.isMobileDevice.Windows()) {
            return window.orientation;
        } else {
            return ($(window).width() > $(window).height())? 90 : 0;
        }
    };

    /**
     * Return true if phonegap/cordova is available.
     * Useful to check if we are in an App or WebApp.
     */
    this.cordovaAvailable = function() {
        return "PhoneGap" in window || "cordova" in window;
    };

    /**
     * Return the Cordova/Phonegap object.
     */
    this.cordova = function() {
        if ("PhoneGap" in window)
            return window.PhoneGap;
        else
            return window.cordova;
    };

    /**
     * Shows a custom alert or dialog box.
     * Title and buttonName aren't considered in Windows Phone.
     *
     * Presenta una alerta en un cuadro de diálogo.
     * Title y buttonName no son tenidos en cuenta en Windows Phone.
     */
    this.alert = function (message, title, buttonName ) {
        if (me.cordovaAvailable() && ("notification" in navigator) && !me.isMobileDevice.Windows())
            navigator.notification.alert(message, function() {}, title, buttonName);
        else
            alert(message);
    };

    /**
     * Show a native Toast (a little text popup with auto hide). It's great for showing a non intrusive native notification.
     * Requires toast plugin. If it's not present, mui.alert is used.
     *
     * Muestra un Toast nativo (un pequeño popup de texto con ocultamiento automático). Es ideal para mostrar una notificación nativa no intrusiva.
     * Requiere toast plugin. Si no está presente, se utiliza mui.alert.
     *
     * position: 'top', 'center', 'bottom'. Default 'center'.
     * duration: 'short', 'long'. Default 'long'.
     */
    this.toast = function(message, position, duration) {
        if ("plugins" in window && "toast" in window.plugins)
            window.plugins.toast.show(message, duration, position);
        else
            mui.alert(message);
    };

    this.busy = function(isBusy, elementId) {
        try {
            var eId;
            if (typeof elementId=='undefined') eId = "body";
            else eId = elementId;
            if (isBusy) $(eId).jqwait('show');
            else $(eId).jqwait('hide');
        } catch(err) {}
    };

    /**
     * Displays a customizable confirmation dialog box.
     * confirmCallback receive a parameter corresponding to the index button, 1, 2, 3, etc.
     * buttonLabels is an array of strings specifying button labels. Defaults to [OK,Cancel]
     *
     * Presenta un cuadro de diálogo de confirmación.
     * confirmCallback recibe un parámetro correspondiente al indice del botón, 1, 2, 3, etc.
     * buttonLabels es un Array de Strings que especifican etiquetas de los botones. Por defecto es [Aceptar, Cancelar]
     */
    this.confirm = function (message, confirmCallback, title, buttonLabels) {
        if (me.cordovaAvailable() && navigator.notification && navigator.notification.confirm) {
            navigator.notification.confirm (
                message,
                confirmCallback,
                title,
                buttonLabels
            );
        } else {
            var ret = confirm(message);
            var buttonIndex = ret?1:2;
            confirmCallback(buttonIndex);
        }
    };
    this.prompt = function (message, promptCallback, title, buttonLabels, defaultText) {
        var def = (defaultText==undefined?'':defaultText);
        if (me.cordovaAvailable() && navigator.notification && navigator.notification.prompt) {
            navigator.notification.prompt(
                message,
                promptCallback,
                title,
                buttonLabels,
                def
            );
        } else {
            var ret = prompt(message, def);
            var result = {};
            result.input1 = ret;
            if (ret==null) result.buttonIndex=2;
            else result.buttonIndex=1;
            promptCallback(result);
        }
    };

    this.beep = function(times) {
        if (me.cordovaAvailable()) {
            if (times==undefined) navigator.notification.beep(1);
            else navigator.notification.beep(times);
        }
    };

    this.vibrate = function(milliSeconds) {
        if (me.cordovaAvailable() &&  "vibrate" in navigator) {
            if (milliSeconds==undefined) navigator.vibrate(2500);
            else navigator.notification.vibrate(milliSeconds);
        }
    };
    /**
     * Creates a link and clicks on it.
     * Crear un link y hacer click sobre �l.
     * @param href
     * @param target
     * @param text
     */
    this.createAndClickHref = function(href, target, text) {
        var a = document.createElement('a');
        a.setAttribute('href',href);
        if (target) a.setAttribute('target',target);
        if (text) a.innerHTML=text;
        document.getElementsByTagName('body')[0].appendChild(a);
        var mouseEvent = a.ownerDocument.createEvent('MouseEvents');
        mouseEvent.initMouseEvent('click', true, true, a.ownerDocument.defaultView, 1, 0, 0, 0, 0, false, false, false, false, 0, null);
        a.dispatchEvent(mouseEvent);
        document.getElementsByTagName('body')[0].removeChild(a);
    };

    this.dialNumber = function(number) {
        me.createAndClickHref('tel:+'+number);
    };
    this.sendSms = function(number, message) {
        me.createAndClickHref('sms:'+number+(me.isMobileDevice.iOS()?';':'?')+'body='+message);
    };

    /**
     * MUI LocalStorage Object
     */
    this.localStorage = {
        /**
         * Return an string or object from the localStorage.
         * Retorna un string u objeto desde el localStorage.
         */
        get: function(key) {
            var value = window.localStorage.getItem(key);
            try {
                var jsonObj = JSON.parse(value);
                return jsonObj;
            } catch (err) {
                return value;
            }
        },
        /**
         * Store data into localStorage. If the data type is not string then convert to JSON.
         * Return de the sotred object, string o JSON as appropriate
         *
         * Almacena un dato en el localStorage. Si el tipo del dato no es string entonces se convierte a JSON.
         * Retorna el objeto almacenado, string o JSON según corresponda.
         */
        set: function(key, value) {
            if (typeof value == 'string') {
                window.localStorage.setItem(key, value);
                return value;
            } else {
                var jsonObj = JSON.stringify(value);
                window.localStorage.setItem(key, jsonObj);
                return jsonObj;
            }
        },
        /**
         * Remove a item from the localStorage.
         */
        remove: function(key) {
            window.localStorage.removeItem(key);
        },
        /**
         * Empty the localStorage.
         * Vacía el localStorage
         */
        clear: function() {
            window.localStorage.clear();
        }
    };

    /* Funciones de red **********************************************************/
    this.connectionAvailable=function() {
        if (me.cordovaAvailable()) {
            var connectionType = me.getConnectionType();
            if (connectionType) return connectionType.toLowerCase()!="none";
            else return false;
        } else {
            return true;	//Asumo que es webapp
        }
    };

    /**
     * Return the connection type:
     * Retorna el tipo de conexión:
     * 		Connection.UNKNOWN
     *		Connection.ETHERNET
     *		Connection.WIFI
     *		Connection.CELL_2G
     *		Connection.CELL_3G
     *		Connection.CELL_4G
     *		Connection.CELL
     *		Connection.NONE
     *		UNKNOWN is API is not available.
     */
    this.getConnectionType=function() {
        var connection = navigator.connection?navigator.connection:(navigator.network && navigator.network.connection)?navigator.network.connection:undefined;
        return typeof connection!="undefined"?connection.type:'unknow';
    };

    /* Funciones de historial ****************************************************/
    function muiBackEventListener() {
        me.history.back();
    };

    this.history = {
        elements: new Array(),	//Objetos {id, effect, viewport, type [1:page, 2:panel]}
        push: function (id, effect, viewport, type, onBack) {
            //Si es el primer elemento de la pila entonces instalo el evento.
            if (me.history.elements==0 && me.cordovaAvailable()) {
                document.addEventListener("backbutton", muiBackEventListener, false);
            }
            me.history.elements.push({id:id, effect:effect, viewport:viewport, type:type, onback:onBack});
        },
        pop: function() {
            var ret = null;
            if (me.history.elements.length>0) {
                ret = me.history.elements.pop();
                if (me.history.elements==0 && me.cordovaAvailable()) {
                    document.removeEventListener("backbutton", muiBackEventListener, false);
                }
            }
            return ret;
        },
        back: function() {
            var obj = me.history.pop();
            if (obj!=null) {
                if (obj.type==1) {
                    var effect;
                    switch (obj.effect) {
                        case 'NONE':
                            effect = 'NONE';
                            break;
                        case 'FADE':
                            effect = 'FADE';
                            break;
                        case 'SLIDE_RIGHT':
                            effect = 'SLIDE_LEFT';
                            break;
                        case 'SLIDE_LEFT':
                            effect = 'SLIDE_RIGHT';
                            break;
                        case 'SLIDE_UP':
                            effect = 'SLIDE_DOWN';
                            break;
                        case 'SLIDE_DOWN':
                            effect = 'SLIDE_UP';
                            break;
                        case 'OVERFLY_IN':
                            effect = 'OVERFLY_OUT';
                            break;
                        case 'OVERFLY_OUT':
                            effect = 'OVERFLY_IN';
                            break;
                        case 'FLOAT_IN':
                            effect = 'FLOAT_OUT';
                            break;
                        case 'FLOAT_OUT':
                            effect = 'FLOAT_IN';
                            break;
                        case 'FLOAT_UP':
                            effect = 'FLOAT_DOWN';
                            break;
                        case 'FLOAT_DOWN':
                            effect = 'FLOAT_UP';
                            break;
                        default:
                            effect = 'NONE';
                    }
                    obj.viewport.showPage(obj.id, effect, null, null, obj.onback, false, true);
                } else if (obj.type==2) {
                    obj.viewport.closePanel(obj.onback, false);
                }
            }
        },
        reset: function() {
            me.history.elements.length=0;
            if (me.cordovaAvailable()) {
                document.removeEventListener("backbutton",  muiBackEventListener, false);
            }
        }

    };

    this.util = {
        /**
         * Returns the distance between two points on the earth indicated by its latitude and longitude.
         *
         * Retorna la distancia entre dos puntos de la tierra indicados a través de su latitud y longitud.
         */
        distanceLatLng: function(lat1,lng1,lat2,lng2,unit) {
            var r;
            if (typeof unit=='undefined' || unit=='K' || unit=='k') r = 6371; // Radius of the earth in km
            else r = 3959; // Radius of the earth in miles
            var d2r = (Math.PI/180);
            var dLat = (lat2-lat1)*d2r;
            var dLng = (lng2-lng1)*d2r;
            var a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(lat1*d2r) * Math.cos(lat2*d2r) * Math.sin(dLng/2) * Math.sin(dLng/2);
            var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            var d = r * c; // Distance in km or miles
            return d;
        }
    };

    this.ajax = function() {
        var url;
        var done;
        var fail;
        var always;
        var param;
        var data;
        if (typeof arguments[0] == 'string') {
            url = arguments[0];
            if (typeof arguments[1] == 'object') {
                data = arguments[1];
                done = arguments[2];
                fail = arguments[3];
                always = arguments[4];
            } else {
                done = arguments[1];
                fail = arguments[2];
                always = arguments[3];
            }
            param = {
                url: url,
                crossDomain: true,
                type: "POST",
                dataType: "html",
                data: data
            };
        } else {
            param = arguments[0];
            done = arguments[1];
            fail = arguments[2];
            always = arguments[3];
        }

        $.ajax(param)
            .done(done)
            .fail(fail)
            .always(always);
    };

    this.fixPlataforms = function() {
        if (me.isMobileDevice.Windows()) {
            window.addEventListener('scroll',function() {
                var dataInterval=null;
                dataInterval = setInterval(function() {
                    var tagName=document.activeElement.tagName.toUpperCase();
                    var fixWPBounceInFocus = (tagName=="INPUT"||tagName=="TEXTAREA"||tagName=="SELECT");
                    if ($("#mui-screen").position().top!=0 && !fixWPBounceInFocus) window.scrollTo(0,0);
                    else clearInterval(dataInterval);
                },100);
            });
        }
        if (me.isMobileDevice.Android()) {
            window.addEventListener('native.keyboardhide', function() {
                $("input[type=text],textarea").blur();
            });
        }
    };

});

/*******************************************************
 * Objetvo Viewport
 *******************************************************/
var Viewport = function(viewportId, currentPageId) {

    var me = this;
    var initialized = false;

    this.viewportId = viewportId;
    this.viewportSelector = "#" + viewportId;
    this.$vp = $(this.viewportSelector);

    var $cover = null;
    var $lastPanel = null;
    var lastPanelEffect = null;
    var inPageTransition=false;
    var inPanelTransition=false;

    // Transition duration in milliseconds
    this.slideDuration = 200;
    this.fadeDuration = 250;

    this.pages = new Array();
    this.currentPageId = currentPageId;	//The document element id of the current page (Page being showed)

    /**
     * Return the document element id of the current page.
     */
    this.getCurrentPageId = function() {
        return this.currentPageId;
    };

    /**
     * Return the id of the current open panel or null if there isn't an open panel.
     *
     * Retorna el id del panel abierto o null si no hay ninguno abierto.
     */
    this.getCurrentPanelId = function() {
        if ($lastPanel!=null) {
            return $lastPanel.attr('id');
        } else return null;
    };

    //Define events variables
    var onShowPage;
    var onPreShowPage;
    var onTouchSwipeLeft;
    var onTouchSwipeRight;
    var onTouchSwipeUp;
    var onTouchSwipeDown;
    var onTouchSwipe;
    var onTouchSwipeLeftDiscover;
    var onTouchSwipeRightDiscover;
    var onTouchSwipeUpDiscover;
    var onTouchSwiperDownDiscover;
    var onResize;
    var touchEventsInstalled=false;

    this.swipeMinDistance=10;
    this.discoverStripWidth=50;

    /**
     * Install event handlers
     */
    this.on = function(eventType, eventHandler) {
        switch (eventType) {
            case 'swipeleft':
                touchHanlers();
                onTouchSwipeLeft = eventHandler;
                break;
            case 'swiperight':
                touchHanlers();
                onTouchSwipeRight = eventHandler;
                break;
            case 'swipeup':
                touchHanlers();
                onTouchSwipeUp = eventHandler;
                break;
            case 'swipedown':
                touchHanlers();
                onTouchSwipeDown = eventHandler;
                break;
            case 'swipe':
                touchHanlers();
                onTouchSwipe = eventHandler;
                break;
            case 'swipeleftdiscover':
                touchHanlers();
                onTouchSwipeLeftDiscover = eventHandler;
                break;
            case 'swiperightdiscover':
                touchHanlers();
                onTouchSwipeRightDiscover = eventHandler;
                break;
            case 'swipeupdiscover':	//Not implemented. Reserved for future versions
                touchHanlers();
                onTouchSwipeUpDiscover = eventHandler;
                break;
            case 'swipedowndiscover': //Not implemented. Reserved for future versions
                touchHanlers();
                onTouchSwiperDownDiscover = eventHandler;
                break;

            case 'showpage':
                onShowPage = eventHandler;
                break;

            case 'preshowpage':
                onPreShowPage = eventHandler;
                break;

            default:
                break;
        }
    };

    /**
     * Private function that install the touch handlers
     */
    function touchHanlers() {
        if (touchEventsInstalled) return;
        else touchEventsInstalled = true;

        var startX = -1;
        var startY = -1;

        var el = document.getElementById(me.viewportId);

        el.addEventListener("touchstart", handleStart, false);
        el.addEventListener("MSPointerDown", handleStart, false);
        el.addEventListener("mousedown", handleStart, false);

        el.addEventListener("touchend", handleEnd, false);
        el.addEventListener("MSPointerUp", handleEnd, false);
        el.addEventListener("mouseup", handleEnd, false);
        el.addEventListener("touchcancel", handleEnd, false);
        el.addEventListener("MSPointerCancel", handleEnd, false);
        el.addEventListener("mousecancel", handleEnd, false);

        function handleStart(event) {
            var touch = event.touches ? event.touches[0] : event;
            startX = touch.pageX;
            startY = touch.pageY;
        }

        function handleEnd(event) {
            try {
                if (startX>-1) {
                    var touch = event.changedTouches ? event.changedTouches[0] : event;
                    var endX = touch.pageX;
                    var endY = touch.pageY;
                    if (startX!=endX) {	//Ignoring the click event
                        var distanceX = Math.abs(startX - endX);
                        var distanceY = Math.abs(startY - endY);
                        var ratio = distanceY/distanceX;
                        var ret = false;
                        // Need to move at least swipeMinDistance pixels for real event
                        if (distanceX>me.swipeMinDistance || distanceX>me.swipeMinDistance ) {
                            if (distanceX>3*distanceY) {	//Horizontal move.
                                if (startX>endX) {	//swipeleft
                                    if (typeof onTouchSwipeLeftDiscover == 'function' && startX>=(me.$vp.width()-me.discoverStripWidth)) {
                                        ret = onTouchSwipeLeftDiscover(me.currentPageId, event.srcElement || event.originalTarget, event, startX, startY, endX, endY);
                                    } else if (typeof onTouchSwipeLeft == 'function') {
                                        ret = onTouchSwipeLeft(me.currentPageId, event.srcElement || event.originalTarget, event, startX, startY, endX, endY);
                                    }
                                } else {	//swiperight
                                    if (typeof onTouchSwipeRightDiscover == 'function' && startX<=me.discoverStripWidth) {
                                        ret = onTouchSwipeRightDiscover(me.currentPageId, event.srcElement || event.originalTarget,event, startX, startY, endX, endY);
                                    } else if (typeof onTouchSwipeRight == 'function') {
                                        ret = onTouchSwipeRight(me.currentPageId, event.srcElement || event.originalTarget,event, startX, startY, endX, endY);
                                    }
                                }
                            } else if (distanceY>3*distanceX) {	//Vertical move.
                                if (startY>endY) { //swipeup
                                    if (typeof onTouchSwipeUp == 'function') {
                                        ret = onTouchSwipeUp(me.currentPageId, event.srcElement || event.originalTarget,event, startX, startY, endX, endY);
                                    }
                                } else { //swipedown
                                    if (typeof onTouchSwipeDown == 'function') {
                                        ret = onTouchSwipeDown(me.currentPageId, event.srcElement || event.originalTarget,event, startX, startY, endX, endY);
                                    }
                                }
                            }
                            if (typeof onTouchSwipe == 'function') {
                                ret = onTouchSwipe(me.currentPageId, event.srcElement || event.originalTarget,event, startX, startY, endX, endY);
                            }
                            if (typeof ret=='undefined' || ret) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                    startX=-1;
                }
            } catch (e) {
                mui.alert(e.message);
            }
        }
    };

    /**
     * Esta función es invocada cuando comienza el cambio de página.
     * Si retorna false el proceso se aborta.
     * @param prevPageId
     * @param pageId
     * @param effect
     * @param parameters
     * @param isBack
     * @returns
     */
    function internalPreShowPage(prevPageId, pageId, effect, parameters, isBack) {
        if (inPageTransition) return false;
        else {
            var ret = true;
            if (typeof onPreShowPage == 'function') ret = onPreShowPage(prevPageId, pageId, effect, parameters, isBack);
            if (ret) inPageTransition = true;
            return ret;
        }
    }

    /**
     * Esta función es invocada cada vez que se presenta una página.
     * El evento es disparado al finalizar la transición.
     * @param prevPageId
     * @param pageId
     * @param effect
     * @param parameters
     * @param isBack
     * @returns
     */
    function internalCompleteShowPage(prevPageId, pageId, effect, parameters, isBack) {
        inPageTransition=false;
        //Initialize all viewports if not yet been initialized.
        //Inicializar todos los viewports si aún no han sido inicializados.
        var all = mui.getAllViewports();
        for (var x=0; x<all.length; x++) {
            all[x].initialize();
        }
        //If the event is defined run it.
        //Si el evento está definido ejecutarlo.
        if (typeof onShowPage == 'function') onShowPage(prevPageId, pageId, effect, parameters, isBack);
    }

    /**
     * Return the default platform effect for page transition.
     * Retorna el efecto por defecto para la plataforma.
     * @returns
     */
    function getDefaultPlatformEffect() {
        var effect;
        if (mui.isMobileDevice.Android()) effect = mui.DEF_ANDROID_EFFECT;
        else if (mui.isMobileDevice.iOS()) effect = mui.DEF_IOS_EFFECT;
        else if (mui.isMobileDevice.Windows()) effect = mui.DEF_WIN_EFFECT;
        else effect = mui.DEF_WEBAPP_EFFECT;
        return effect;
    }

    /**
     * Show the page identified by the document element id.
     */
    this.showPage = function(pageId, effect, parameters, onComplete, onBack, prevInHistory, isBack) {
        if (effect=='DEF') effect = getDefaultPlatformEffect();
        if (typeof parameters == 'function') {
            isBack = prevInHistory;
            prevInHistory = onBack;
            onBack = onComplete;
            onComplete = parameters;
        }
        if (pageId != me.currentPageId) {
            //Invoco la previa.
            var prevPageId = me.currentPageId;
            if (!internalPreShowPage(prevPageId, pageId, effect, parameters)) return;
            me.currentPageId = pageId;
            var $pageIn = $("#" + pageId);
            var $pageOut = $("#" + prevPageId);
            //Si el alto no coincide con el del Viewport lo ajusto.
            if ($pageIn.height()!=me.$vp.height()) $pageIn.height(me.$vp.height());
            switch (effect) {
                case 'NONE':
                    $pageOut.css({
                        top: '100%',
                        left: '100%',
                        'z-index': '0',
                        display: 'block'
                    });
                    $pageIn.css({
                        top : '0px',
                        left : '0px',
                        'z-index': '1',
                        display: 'block'
                    });
                    if (typeof onComplete == 'function') onComplete(prevPageId, pageId, effect, parameters, isBack);
                    internalCompleteShowPage(prevPageId, pageId, effect, parameters, isBack);
                    break;
                case 'FADE':
                    $pageIn.css('z-index', '0').hide();
                    $pageOut.css('z-index', '1');
                    $pageIn.css({
                        top : '0px',
                        left : '0px',
                    }).hide();
                    $pageOut.fadeOut(this.fadeDuration, function() {
                        $pageOut.css({
                            top: '100%',
                            left: '100%',
                            display: 'block',
                            'z-index': '0'
                        });
                    });
                    $pageIn.fadeIn(this.fadeDuration, function() {
                        $pageIn.css('z-index', '1');
                        if (typeof onComplete == 'function') onComplete(prevPageId, pageId, effect, parameters, isBack);
                        internalCompleteShowPage(prevPageId, pageId, effect, parameters, isBack);
                    });
                    break;
                case 'SLIDE_RIGHT':
                    $pageIn.css('z-index', '1');
                    $pageOut.css('z-index', '0');
                    // Posiciono la nueva página.
                    $pageIn.css({
                        top : '0px',
                        left : '-' + me.$vp.width() + 'px',
                    });
                    $pageOut.animate({
                        left : me.$vp.width() + 'px'
                    }, this.slideDuration);
                    $pageIn.animate({
                        left : '0px'
                    }, this.slideDuration, function() {
                        if (typeof onComplete == 'function') onComplete(prevPageId, pageId, effect, parameters, isBack);
                        internalCompleteShowPage(prevPageId, pageId, effect, parameters, isBack);
                    });
                    break;
                case 'SLIDE_LEFT':
                    $pageIn.css('z-index', '1');
                    $pageOut.css('z-index', '0');
                    // Posiciono la nueva página.
                    $pageIn.css({
                        top : '0px',
                        left : me.$vp.width() + 'px',
                    });
                    $pageOut.animate({
                        left : '-' + me.$vp.width() + 'px'
                    }, this.slideDuration);
                    $pageIn.animate({
                        left : '0px'
                    }, this.slideDuration, function() {
                        if (typeof onComplete == 'function') onComplete(prevPageId, pageId, effect, parameters, isBack);
                        internalCompleteShowPage(prevPageId, pageId, effect, parameters, isBack);
                    });
                    break;
                case 'SLIDE_UP':
                    $pageIn.css('z-index', '1');
                    $pageOut.css('z-index', '0');
                    // Posiciono la nueva página.
                    $pageIn.css({
                        top : me.$vp.height() + 'px',
                        left : '0px',
                    });
                    $pageOut.animate({
                        top : '-' + me.$vp.height() + 'px'
                    }, this.slideDuration);
                    $pageIn.animate({
                        top : '0px'
                    }, this.slideDuration, function() {
                        if (typeof onComplete == 'function') onComplete(prevPageId, pageId, effect, parameters, isBack);
                        internalCompleteShowPage(prevPageId, pageId, effect, parameters, isBack);
                    });
                    break;
                case 'SLIDE_DOWN':
                    $pageIn.css('z-index', '1');
                    $pageOut.css('z-index', '0');
                    // Posiciono la nueva página.
                    $pageIn.css({
                        top : '-' + me.$vp.height() + 'px',
                        left : '0px'
                    });
                    $pageOut.animate({
                        top : me.$vp.height() + 'px'
                    }, this.slideDuration);
                    $pageIn.animate({
                        top : '0px'
                    }, this.slideDuration, function() {
                        if (typeof onComplete == 'function') onComplete(prevPageId, pageId, effect, parameters, isBack);
                        internalCompleteShowPage(prevPageId, pageId, effect, parameters, isBack);
                    });
                    break;
                case 'OVERFLY_IN':
                    $pageIn.css("z-index", "1");
                    $pageOut.css("z-index", "0");
                    // Posiciono la nueva página.
                    $pageIn.css({
                        top : '0px',
                        left : me.$vp.width() + 'px',
                    });
                    $pageOut.animate({
                        left : '-' + me.$vp.width()/5 + 'px'
                    }, this.slideDuration*1.5, function() {
                        $pageOut.css({
                            top : '0px',
                            left : '-' + me.$vp.width() + 'px',
                        });
                    });
                    $pageIn.animate({
                        left : '0px'
                    }, this.slideDuration*1.5, function() {
                        if (typeof onComplete == 'function') onComplete(prevPageId, pageId, effect, parameters, isBack);
                        internalCompleteShowPage(prevPageId, pageId, effect, parameters, isBack);
                    });
                    break;
                case 'OVERFLY_OUT':
                    $pageIn.css("z-index", "0");
                    $pageOut.css("z-index", "1");
                    // Posiciono la nueva página.
                    $pageIn.css({
                        top : '0px',
                        left: '-' + me.$vp.width()/5 + 'px'
                    });
                    $pageOut.animate({
                        left : me.$vp.width() + 'px'
                    }, this.slideDuration*1.5);
                    $pageIn.animate({
                        left : '0px'
                    }, this.slideDuration*1.5, function() {
                        if (typeof onComplete == 'function') onComplete(prevPageId, pageId, effect, parameters, isBack);
                        internalCompleteShowPage(prevPageId, pageId, effect, parameters, isBack);
                    });
                    break;
                case 'FLOAT_IN':
                    $pageIn.css("z-index", "1");
                    $pageOut.css("z-index", "0");
                    // Posiciono la nueva página.
                    $pageIn.css({
                        top : '0px',
                        left : me.$vp.width() + 'px',
                    });
                    $pageIn.animate({
                        left : '0px'
                    }, this.slideDuration*1.5, function() {
                        $pageOut.css({
                            top : '0px',
                            left : me.$vp.width() + 'px',
                        });
                        if (typeof onComplete == 'function') onComplete(prevPageId, pageId, effect, parameters, isBack);
                        internalCompleteShowPage(prevPageId, pageId, effect, parameters, isBack);
                    });
                    break;
                case 'FLOAT_OUT':
                    $pageIn.css("z-index", "0");
                    $pageOut.css("z-index", "1");
                    // Posiciono la nueva página.
                    $pageIn.css({
                        top : '0px',
                        left: '0px'
                    });
                    $pageOut.animate({
                        left : me.$vp.width() + 'px'
                    }, this.slideDuration*1.5);
                    $pageIn.animate({
                        left : '0px'
                    }, this.slideDuration*1.5, function() {
                        if (typeof onComplete == 'function') onComplete(prevPageId, pageId, effect, parameters, isBack);
                        internalCompleteShowPage(prevPageId, pageId, effect, parameters, isBack);
                        $pageIn.css('z-index', '1');
                        $pageOut.css('z-index', '0');
                    });
                    break;

                case 'FLOAT_DOWN':
                    $pageIn.css("z-index","0");
                    $pageOut.css("z-indez","1");
                    // Posiciono la nueva página.
                    $pageIn.css({
                        top : '0px',
                        left: '0px'
                    });
                    $pageOut.animate({
                        top :  me.$vp.height() + 'px'
                    }, this.slideDuration*1.5);
                    $pageIn.animate({
                        top : '0px'
                    }, this.slideDuration*1.5, function() {
                        if (typeof onComplete == 'function') onComplete(prevPageId, pageId, effect, parameters, isBack);
                        internalCompleteShowPage(prevPageId, pageId, effect, parameters, isBack);
                        $pageIn.css('z-index', '1');
                        $pageOut.css('z-index', '0');
                    });
                    break;

                case 'FLOAT_UP':

                    $pageIn.css("z-index","1");
                    $pageOut.css("z-index","0")
                    $pageIn.css({
                        top :  me.$vp.height() + 'px',
                        left : '0px',
                    });
                    $pageIn.animate({
                        top : '0px'
                    }, this.slideDuration*1.5, function() {
                        $pageOut.css({
                            top : '0px',
                            left : me.$vp.width() + 'px',
                        });
                        if (typeof onComplete == 'function') onComplete(prevPageId, pageId, effect, parameters, isBack);
                        internalCompleteShowPage(prevPageId, pageId, effect, parameters, isBack);
                    });
                    break;

            }
            if (prevInHistory == undefined || prevInHistory == true) {
                mui.history.push(prevPageId, effect, this, 1, onBack);
            }
            this.refreshScroll();
        }
    };


    function internalPreShowPanel(currentPage, panelId, effect) {
        if (inPanelTransition) return false;
        else {
            inPanelTransition = true;
            return true;
        }
    };

    function internalCompleteShowPanel(currentPage, panelId, effect) {
        inPanelTransition=false;
        //Initialize all viewports if not yet been initialized.
        //Inicializar todos los viewports si aún no han sido inicializados.
        var all = mui.getAllViewports();
        for (var x=0; x<all.length; x++) {
            all[x].initialize();
        }
    };

    this.centerElement = function(element, container) {
        if (typeof container == "undefined") center$Element($(element));
        else me.center$Element($('#'+element), $('#'+container));
    };

    this.center$Element = function($element, $container) {
        if (typeof $container=="undefined") $container=me.$vp;
        $element.css({left:(($container.width()-$element.width())/2) + 'px',top: (($container.height()-$element.height())/2) +'px'});
    };

    this.showPanel = function(panelId, effect, onComplete, onBack, inHistory) {
        if ($lastPanel == null) {
            if (!internalPreShowPanel(this.currentPage, panelId, effect)) return;
            this.putCoverShield(null, function() {
                me.closePanel();
            });
            var panelIn = "#" + panelId;
            $lastPanel = $(panelIn);
            var $pageOut = $("#" + this.currentPageId);
            switch (effect) {
                case 'NONE':
                    $lastPanel.css({
                        display: 'block',
                    });
                    if (typeof onComplete == 'function') onComplete(this.currentPage, panelId, effect);
                    internalCompleteShowPanel(this.currentPage, panelId, effect);
                    break;
                case 'FADE':
                    $lastPanel.css({
                        display: 'none'
                    });
                    $lastPanel.fadeIn(this.fadeDuration, function() {
                        if (typeof onComplete == 'function') onComplete(this.currentPage, panelId, effect);
                        internalCompleteShowPanel(this.currentPage, panelId, effect);
                    });
                    break;
                case 'SLIDE_RIGHT':
                    // Posiciono la nueva página.
                    $lastPanel.css({
                        left : (-1 * $lastPanel.width()) + 'px',
                    }).animate({
                        left : '0px'
                    }, this.slideDuration);
                    $pageOut.animate({
                        left : $lastPanel.width() + 'px'
                    }, this.slideDuration, function() {
                        if (typeof onComplete == 'function') onComplete(this.currentPage, panelId, effect);
                        internalCompleteShowPanel(this.currentPage, panelId, effect);
                    });
                    break;
                case 'SLIDE_LEFT':
                    // Posiciono la nueva página.
                    $lastPanel.css({
                        left : me.$vp.width() + 'px',
                    });
                    $lastPanel.animate({
                        left : (me.$vp.width() - $lastPanel.width()) + 'px'
                    }, this.slideDuration);
                    $pageOut.animate({
                        left : (-1 * $lastPanel.width()) + 'px'
                    }, this.slideDuration, function() {
                        if (typeof onComplete == 'function') onComplete(this.currentPage, panelId, effect);
                        internalCompleteShowPanel(this.currentPage, panelId, effect);
                    });
                    break;
                case 'FLOAT_RIGHT':
                    // Posiciono la nueva página.
                    $lastPanel.css({
                        left : (-1 * $lastPanel.width()) + 'px',
                    }).animate({
                        left : '0px'
                    }, this.slideDuration, function() {
                        if (typeof onComplete == 'function') onComplete(this.currentPage, panelId, effect);
                        internalCompleteShowPanel(this.currentPage, panelId, effect);
                    });
                    break;
                case 'FLOAT_LEFT':
                    $lastPanel.css({
                        left : me.$vp.width() + 'px',
                    }).animate({
                        left : (me.$vp.width() - $lastPanel.width()) + 'px'
                    }, this.slideDuration, function() {
                        if (typeof onComplete == 'function') onComplete(this.currentPage, panelId, effect);
                        internalCompleteShowPanel(this.currentPage, panelId, effect);
                    });
                    break;
                case 'SLIDE_UP':
                    // Posiciono la nueva página.
                    $lastPanel.css({
                        top : me.$vp.height() + 'px',
                    }).animate({
                        top : (me.$vp.height() - $lastPanel.height()) + 'px'
                    }, this.slideDuration);
                    $pageOut.animate({
                        top : (-1 * $lastPanel.height()) + 'px'
                    }, this.slideDuration, function() {
                        if (typeof onComplete == 'function') onComplete(this.currentPage, panelId, effect);
                        internalCompleteShowPanel(this.currentPage, panelId, effect);
                    });
                    break;
                case 'SLIDE_DOWN':
                    // Posiciono la nueva página.
                    $lastPanel.css({
                        top : (-1 * $lastPanel.height()) + 'px',
                    }).animate({
                        top : '0px'
                    }, this.slideDuration);
                    $pageOut.animate({
                        top : ($lastPanel.height()) + 'px'
                    }, this.slideDuration, function() {
                        if (typeof onComplete == 'function') onComplete(this.currentPage, panelId, effect);
                        internalCompleteShowPanel(this.currentPage, panelId, effect);
                    });
                    break;
                case 'FLOAT_UP':
                    $lastPanel.css({
                        top : me.$vp.height() + 'px',
                    });
                    $lastPanel.animate({
                        top : (me.$vp.height() - $lastPanel.height()) + 'px'
                    }, this.slideDuration, function() {
                        if (typeof onComplete == 'function') onComplete(this.currentPage, panelId, effect);
                        internalCompleteShowPanel(this.currentPage, panelId, effect);
                    });
                    break;
                case 'FLOAT_DOWN':
                    $lastPanel.css({
                        top : (-1 * $lastPanel.height()) + 'px',
                    }).animate({
                        top : '0px'
                    }, this.slideDuration, function() {
                        if (typeof onComplete == 'function') onComplete(this.currentPage, panelId, effect);
                        internalCompleteShowPanel(this.currentPage, panelId, effect);
                    });
                    break;
                default:
                    return;
            }
            if (inHistory == undefined || inHistory == true) {
                mui.history.push(panelId, effect, this, 2, onBack);
            }
            lastPanelEffect = effect;
            me.refreshScroll();
        }

    };

    this.panelIsOpen = function() {
        return $lastPanel != null;
    };

    this.closePanel = function(complete, removeHistory) {
        if (me.panelIsOpen() && !inPanelTransition) {
            inPanelTransition=true;
            me.removeCoverShield();
            var $pageIn = $("#" + this.currentPageId);
            var lastPanelId = $lastPanel.attr('id');
            switch (lastPanelEffect) {
                case 'NONE':
                    $lastPanel.css({
                        display: 'none',
                    });
                    me.removeCoverShield();
                    if (typeof complete == 'function') complete(this.currentPage, lastPanelId, lastPanelEffect);
                    inPanelTransition=false;
                    break;
                case 'FADE':
                    $lastPanel.fadeOut(this.fadeDuration, function() {
                        if (typeof complete == 'function') complete(this.currentPage, lastPanelId, lastPanelEffect);
                        inPanelTransition=false;
                    });
                    break;
                case 'SLIDE_RIGHT':
                    $pageIn.animate({
                        left : '0px'
                    }, this.slideDuration);
                    $lastPanel.animate({
                        left : (-1 * $lastPanel.width()) + 'px',
                    }, this.slideDuration, function() {
                        if (typeof complete == 'function') complete(this.currentPage, lastPanelId, lastPanelEffect);
                        inPanelTransition=false;
                    });
                    break;
                case 'SLIDE_LEFT':
                    // Posiciono la nueva página.
                    $lastPanel.animate({
                        top : '0px',
                        left : me.$vp.width() + 'px',
                    }, this.slideDuration, function() {
                        if (typeof complete == 'function') complete(this.currentPage, lastPanelId, lastPanelEffect);
                        inPanelTransition=false;
                    });
                    $($pageIn).animate({
                        left : '0px'
                    }, this.slideDuration);
                    break;
                case 'FLOAT_RIGHT':
                    $lastPanel.animate({
                        left : (-1 * $lastPanel.width()) + 'px',
                    }, this.slideDuration, function() {
                        if (typeof complete == 'function') complete(this.currentPage, lastPanelId, lastPanelEffect);
                        inPanelTransition=false;
                    });
                    break;
                case 'FLOAT_LEFT':
                    $lastPanel.animate({
                        left : me.$vp.width() + 'px',
                    }, this.slideDuration, function() {
                        $(this).css('visibility','hidden');
                        if (typeof complete == 'function') complete(this.currentPage, lastPanelId, lastPanelEffect);
                        inPanelTransition=false;
                    });
                    break;
                case 'SLIDE_UP':
                    $lastPanel.animate({
                        top : me.$vp.height() + 'px'
                    }, this.slideDuration, function() {
                        if (typeof complete == 'function') complete(this.currentPage, lastPanelId, lastPanelEffect);
                        inPanelTransition=false;
                    });
                    $pageIn.animate({
                        top : '0px'
                    }, this.slideDuration);
                    break;
                case 'SLIDE_DOWN':
                    $pageIn.animate({
                        top : '0px'
                    }, this.slideDuration);
                    $lastPanel.animate({
                        top : (-1 * $lastPanel.height()) + 'px'
                    }, this.slideDuration, function() {
                        if (typeof complete == 'function') complete(this.currentPage, lastPanelId, lastPanelEffect);
                        inPanelTransition=false;
                    });
                    break;
                case 'FLOAT_UP':
                    $lastPanel.animate({
                        top : me.$vp.height() + 'px'
                    }, this.slideDuration, function() {
                        if (typeof complete == 'function') complete(this.currentPage, lastPanelId, lastPanelEffect);
                        inPanelTransition=false;
                    });
                    break;
                case 'FLOAT_DOWN':
                    $lastPanel.animate({
                        top : (-1 * $lastPanel.height()) + 'px'
                    }, this.slideDuration, function() {
                        if (typeof complete == 'function') complete(this.currentPage, lastPanelId, lastPanelEffect);
                        inPanelTransition=false;
                    });
                    break;
                default:
                    return;
            }
            $lastPanel = null;
            if (removeHistory == undefined || removeHistory == true) mui.history.pop();
        }
    };

    /**
     * Use installScroll.
     * @deprecated
     */
    this.useIScroll = function(iScrollArg) {
        if (document.addEventListener && !mui.isMobileDevice.Windows()) {	//Navegadores modernos.
            var scrollArg;
            var scrollArgNotUseTransform;
            if (iScrollArg == undefined) {
                //Si es Android versión 2.xxx entonces uso useTransform en false
                var auxTransform = true;
                var ua = navigator.userAgent;
                if( ua.indexOf("Android") >= 0 ) {
                    var androidversion = parseFloat(ua.slice(ua.indexOf("Android")+8));
                    if (androidversion <= 3) auxTransform = false;
                }
                var any = mui.isMobileDevice.any();
                scrollArg = {
                    click : false,
                    preventDefault : any ? false: false, // false en This is the case for Firefox, Chrome and Safari when testing on a desktop.
                    scrollbars : any ? false : true,
                    fadeScrollbar :any ? false : true,
                    mouseWheel : any ? false : true,
                    interactiveScrollbars : any ? false : true,
                    keyBindings : any ? false : true,
                    useTransform: auxTransform
                };
            } else {
                scrollArg = iScrollArg;
            }
            scrollArgNotUseTransform =  $.extend({}, scrollArg);
            scrollArgNotUseTransform.useTransform = false;
            scrollArgNotUseTransform.useTransition = false;
            $(me.viewportSelector + " .mui-scrollable").each(function() {
                $this = $(this);
                var use = true;
                if ( $this.hasClass('mui-notUseTransform') ) use=false;
                else if ( $this.hasClass('ios-notUseTransform') && mui.isMobileDevice.iOS() ) use=false;
                else if ( $this.hasClass('android-notUseTransform') && mui.isMobileDevice.iOS() ) use=false;
                else if ( $this.hasClass('windows-notUseTransform') && mui.isMobileDevice.iOS() ) use=false;
                if ($this.hasClass("mui-zoomable")) {
                    if (use) {
                        scrollArg.scrollX=true;
                        scrollArg.scrollY=true;
                        scrollArg.freeScroll=true;
                        scrollArg.zoom=true;
                    } else {
                        scrollArgNotUseTransform.scrollX=true;
                        scrollArgNotUseTransform.scrollY=true;
                        scrollArgNotUseTransform.freeScroll=true;
                        scrollArgNotUseTransform.zoom=true;
                    }
                } else {
                    if (use) scrollArg.zoom=false;
                    else scrollArgNotUseTransform.zoom=false;
                }

                if ($this.children('.mui-scroll-wrapper').length==0) {
                    $this.css("overflow", "hidden");
                    $this.children().wrapAll("<div class='mui-scroll-wrapper' />");;
                    var iScroll = new IScroll(this, (use?scrollArg:scrollArgNotUseTransform));
                    $this.data('iScroll', iScroll);
                }
            });
            document.addEventListener('touchmove', function(e) {
                e.preventDefault();
            }, false);
        } else {
            $(".mui-scrollable").css({'overflow-y':'auto','overflow-x':'hidden'});
        }

    };

    /**
     * Use refreshScroll Instead of this method.
     * @deprectated
     */
    this.iScrollRefresh = function(id) {
        var s;
        if (id == undefined) { //If id is undefined I get all mui-scrollable elements below the viewport
            s = this.viewportSelector + " .mui-scrollable";
        } else { // Else I get all mui-scrollable elements below the page id.
            s = "#" + id + " .mui-scrollable";
        }
        // Obtengo el objeto iScroll y si existe lo refresco.
        $(s).each(function() {
            $this = $(this);
            var iScroll = $this.data('iScroll');
            if (iScroll!=undefined) {
                iScroll.refresh();
            }
        });
    };

    /**
     * Refreshes the scroll on all elements with class mui-scrollable or, if specifies an id, only on this element.
     *
     * Actualiza el scroll en todos los elementos con clase mui-scrollable o, si se especifica un id, solo en ese elemento.
     *
     * Typical use: mui.viewport.refreshScroll()
     */
    this.refreshScroll = function(id) {
        this.iScrollRefresh(id);
    };

    /**
     * Installs scroll on all elements with class mui-scrollable.
     * The parameter scrollArg is dependent of the scroll engine (eg: iScroll).
     *
     * Instala scroll en todos los elementos con clase mui-scrollable.
     * El parámetro scrollArg es dependiente de la ingeniería de scorll utilizada (ej: iScroll):
     */
    this.installScroll = function(scrollArg) {
        this.useIScroll(scrollArg);
    };

    /**
     * Uninstall the scroll of all elements.
     *
     * Desinistala el scroll de todos los elementos.
     */
    this.removeScroll = function(id) {
        var s;
        if (id == undefined) { //If id is undefined I get all mui-scrollable elements below the viewport
            s = this.viewportSelector + " .mui-scrollable";
        } else { // Else I get all mui-scrollable elements below the page id.
            s = "#" + id + " .mui-scrollable";
        }
        $(s).each(function() {
            $this = $(this);
            var iScroll = $this.data('iScroll');
            if (iScroll!=undefined) {
                iScroll.destroy();
                iScroll=null;
            }
        });
    };

    /**
     * Puts a cover Shield div on the current page avoiding events clicks and others.
     * The shield is a <div class=cssClass ...> being the default cssClass value, if not specified, mui-cover-shield.
     *
     * Coloca un div escudo sobre la página actual para evitar clicks.
     * El escuedo es un <div class=cssClass ...>, siendo cssClass='mui-cover-shield' por defecto si no se indica.
     */
    this.putCoverShield = function(cssClass, onClick) {
        if ($cover == null) {
            $cover = $("<div />");
            me.$vp.append($cover);
        }
        if (onClick != undefined) {
            $cover.click(function() {
                onClick();
            });
        }
        if (cssClass != undefined && cssClass != null) {
            $cover.attr("class", cssClass);
        } else {
            $cover.attr("class", "mui-cover-shield");
        }
        $cover.css({
            position : 'absolute',
            top : '0px',
            left : '0px',
            width:'100%',
            height:'100%',
            display : 'block'
        });
    };

    /**
     * Remove a cover shield
     *
     * Quita el escudo
     */
    this.removeCoverShield = function() {
        if ($cover != null) {
            $cover.css({
                left : '100%',
            }).removeClass().unbind('click');
        }
    };

    /**
     * Add blur effect on the current page
     *
     * Añadir efecto de desenfoque a la página actual
     */
    this.blur = function(cssClass) {
        var css=cssClass!=undefined?cssClass:'mui-blur';
        $("#" + this.currentPageId).addClass(css);
    };

    /**
     * Remove the blur effect
     *
     * Quita el efecto de desenfoque
     */
    this.unblur = function(cssClass) {
        var css=cssClass!=undefined?cssClass:'mui-blur';
        $("#" + this.currentPageId).removeClass(css);
    };

    /**
     * Used to notify its container viewport resized.
     *
     * Se usa para notificar al viewport que su contenedor cambió de tamaño.
     */
    this.resize = function() {
        $("#"+me.currentPageId).height(me.$vp.height());
        me.refreshScroll();
    };

    this.initialize = function() {
        if (!initialized) {
            if (me.$vp.is(":visible")) {
                initialized = true;
                //Get default page.
                //Obtengo la página por defecto.
                if (typeof me.currentPageId == "undefined") {
                    me.currentPageId = me.$vp.find(".mui-page").first().attr("id");
                }
                var aux = me.currentPageId;
                me.currentPageId="";
                this.showPage(aux, 'NONE');
                me.installScroll();
                setTimeout(function() {me.refreshScroll(me.currentPageId);},200);
                //if (typeof onShowPage == 'function') onShowPage(null, me.currentPageId, 'NONE', null, false);
            }
        }
    };
    me.initialize();
};

/******************************************************************************
 * Punto de inicio.
 ******************************************************************************/
$(document).ready(function() {
    //Opciones estándares
    var options = {
        standarScreen: true,
        standarViewport: true,
        resize: true,
        standarBackEvent: true,
        useFastclick: true
    };
    //If preDeviceReady function is defined then invoke it. This can modify the standard options.
    //Si está definida la función preDeviceReady la invoco. Esta puede modificar las opciones est�ndares.
    if (typeof preDeviceReady == 'function') {
        var newOptions = preDeviceReady(options);
        options = $.extend(options, newOptions);
    }
    if (options.useFastclick) FastClick.attach(document.body);
    if (options.standarScreen) {
        //Sets the size of the viewport Screen. It is important to properly move the keyboard on focus on input element.
        //Establezco el tamaño del viewport Screen. Es importante para que el teclado desplace correctamente la pantalla al hacer foco sobre un input.
        var adjustOrientation = function() {
            $("div#mui-screen").css("width", (window.innerWidth) + "px");
            $("div#mui-screen").css("height", (window.innerHeight) + "px");
            if (mui.screen) mui.screen.resize();
            if (options.standarViewport && mui.viewport)  mui.viewport.resize();
        };
        adjustOrientation();
        if (typeof mui.defaultScreenPage=="undefined") mui.screen = new Viewport('mui-screen');
        else mui.screen = new Viewport('mui-screen', mui.defaultScreenPage);
        mui.registerViewport(mui.screen);
    }
    if (options.standarViewport) {
        if (typeof mui.defaultViewportPage=="undefined") mui.viewport = mui.createViewport('mui-viewport');
        else mui.viewport = mui.createViewport('mui-viewport', mui.defaultViewportPage);
    }
    if (options.resize) {
        var currentWidth = window.innerWidth;
        $(window).resize(function() {
            var lastWidth = window.innerWidth;
            if (currentWidth!=lastWidth) {	//Orientation changed. La orientación cambió.
                if (options.standarScreen) {
                    //Sets the size of the viewport Screen. It is important to properly move the keyboard on focus on input element.
                    //Establezco el tamaño del viewport Screen. Es importante para que el teclado desplace correctamente la pantalla al hacer foco sobre un input.
                    currentWidth=lastWidth;
                    adjustOrientation();
                }
                //Invoke the standard resize events in each viewport, if defined.
                //Invoco los eventos resize en cada viewport estandar, si está definido.
                var all = mui.getAllViewports();
                for (var x=0; x<all.length; x++) all[x].resize();
            }
        });
    }
    mui.fixPlataforms();
    if (mui.cordovaAvailable()) {	//true si es una app nativa.
        document.addEventListener("deviceready", function () {	//evento cordova ready
            if (typeof deviceReady == 'function') deviceReady();
        }, false);
    } else { //web app
        if (typeof deviceReady == 'function') deviceReady();
    }
});
